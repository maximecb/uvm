//
// UVM Basic
// by Abdul Bahajaj
// 
// Note to reader: When I authored this VM there were a lot of missing features from the NCC compiler ( e.g. there are no structs, unions, etc...).
// Keeping this in mind might help you understand why the code is structured in the way it is.


#include <stddef.h>
#include <string.h>
#include <uvm/syscalls.h>
#include <uvm/utils.h>
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <uvm/graphics.h>

#define FONT_MONOGRAM_NUMBER_OF_CHARACTERS 390
#define FONT_MONOGRAM_HEIGHT 12
#define FONT_MONOGRAM_WIDTH 7


#define FRAME_WIDTH 1200
#define FRAME_HEIGHT 700
#define NUM_COLS 25
#define NUM_ROWS 21


#ifdef DEBUG
#define DEBUGS(s) puts(__FILE__ " : "); print_i64(__LINE__); puts(" "); puts(s);
#define DEBUGI(i) print_i64(i);
#else 
#define DEBUGS(s) 
#define DEBUGI(i) 
#endif

#define DEBUG(s) DEBUGS(s "\n");

#define TRY(exp) if(exp) return 1;
#define NULLGAURD(ptr) if(ptr == NULL) return NULL;


size_t console_width;

size_t margin = 5;
size_t char_width = 18;
size_t char_height = 32;

u32 frame_buffer[FRAME_HEIGHT][FRAME_WIDTH];

char text[NUM_ROWS][NUM_COLS];


// Position of the cursor
size_t line_idx = 0;
size_t min_line_idx = 4;
size_t col_idx = 0;

size_t row_len(size_t row_idx)
{
	for (int i = 0; i < NUM_COLS; ++i)
	{
		if (text[row_idx][i] == 0)
		{
			return i;
		}
	}

	return NUM_COLS;
}

u32* get_point_ptr(u32* dst, size_t frame_width, size_t x, size_t y)
{
	return dst + frame_width* y + x;
}

int blue = 0x0247fe; 
int red = 0xFF0000; 
int green = 0x008000; 
int black = 0x0; 

void textinput(u64 window_id, char ch)
{
	console_putchar(ch);
	vm_command_text_buffer[vm_command_text_buffer_cursor] = ch;
	DEBUGS(vm_command_text_buffer);
	DEBUGS("\n");
	++vm_command_text_buffer_cursor;
	console_redraw_commit();
}

void keydown(u64 window_id, u16 keycode)
{
	if (keycode == KEY_ESCAPE)
	{
		exit(0);
	}
	else if (keycode == KEY_BACKSPACE)
	{
		if (col_idx > 0)
		{
			col_idx = col_idx - 1;
			vm_command_text_buffer_backspace();
		}
		else if (line_idx > min_line_idx)
		{
			console_redraw_line(line_idx);
			line_idx = line_idx - 1;
			col_idx = row_len(line_idx);
		}

		text[line_idx][col_idx] = 0;
	}
	else if (keycode == KEY_RETURN)
	{

		vm_load_cmd();
		console_newline();
		min_line_idx = line_idx;
	}
	console_redraw_commit();
}

void anim_callback()
{
	console_redraw_commit();
	/* benchmark(); */

	time_delay_cb(400, anim_callback);
}

void console_print_ready() {
	console_newline();
	console_puts("READY.");
}


void main()
{
	DEBUGS("DEBUGGING\n");
	console_width = FRAME_WIDTH/3+75;
	vm_init();
	vm_command_text_buffer_clear();
	window_create(FRAME_WIDTH, FRAME_HEIGHT, "UVM Basic", 0);

	canvas_clear();
	console_redraw_all_text();

	console_puts("  **** UVM Basic ****");
	console_newline();
	console_puts("Type HELP for available commands");
	console_print_ready();
	console_newline();

	console_redraw_commit();

	window_on_keydown(0, keydown);
	window_on_textinput(0, textinput);

	time_delay_cb(0, anim_callback);

	enable_event_loop();
}

//===========================================================================
/* CONSOLE */

// This is 12 bytes of data per char, as in 12 rows, and each byte
// represents the pixels in that row.
u8 font_monogram_data[FONT_MONOGRAM_NUMBER_OF_CHARACTERS][FONT_MONOGRAM_HEIGHT] = {
	{ 0x00, 0x00, 0x00, 0x0e, 0x11, 0x19, 0x15, 0x13, 0x11, 0x0e, 0x00, 0x00, }, // '0'
	{ 0x00, 0x00, 0x00, 0x04, 0x06, 0x04, 0x04, 0x04, 0x04, 0x1f, 0x00, 0x00, }, // '1'
	{ 0x00, 0x00, 0x00, 0x0e, 0x11, 0x10, 0x08, 0x04, 0x02, 0x1f, 0x00, 0x00, }, // '2'
	{ 0x00, 0x00, 0x00, 0x0e, 0x11, 0x10, 0x0c, 0x10, 0x11, 0x0e, 0x00, 0x00, }, // '3'
	{ 0x00, 0x00, 0x00, 0x12, 0x12, 0x11, 0x1f, 0x10, 0x10, 0x10, 0x00, 0x00, }, // '4'
	{ 0x00, 0x00, 0x00, 0x1f, 0x01, 0x0f, 0x10, 0x10, 0x11, 0x0e, 0x00, 0x00, }, // '5'
	{ 0x00, 0x00, 0x00, 0x0e, 0x01, 0x01, 0x0f, 0x11, 0x11, 0x0e, 0x00, 0x00, }, // '6'
	{ 0x00, 0x00, 0x00, 0x1f, 0x10, 0x10, 0x08, 0x04, 0x04, 0x04, 0x00, 0x00, }, // '7'
	{ 0x00, 0x00, 0x00, 0x0e, 0x11, 0x11, 0x0e, 0x11, 0x11, 0x0e, 0x00, 0x00, }, // '8'
	{ 0x00, 0x00, 0x00, 0x0e, 0x11, 0x11, 0x1e, 0x10, 0x11, 0x0e, 0x00, 0x00, }, // '9'
	{ 0x00, 0x00, 0x00, 0x04, 0x04, 0x04, 0x04, 0x04, 0x00, 0x04, 0x00, 0x00, }, // '!'
	{ 0x00, 0x00, 0x00, 0x0a, 0x0a, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }, // '"'
	{ 0x00, 0x00, 0x00, 0x00, 0x0a, 0x1f, 0x0a, 0x0a, 0x1f, 0x0a, 0x00, 0x00, }, // '#'
	{ 0x00, 0x00, 0x00, 0x04, 0x1e, 0x05, 0x0e, 0x14, 0x0f, 0x04, 0x00, 0x00, }, // '$'
	{ 0x00, 0x00, 0x00, 0x11, 0x11, 0x08, 0x04, 0x02, 0x11, 0x11, 0x00, 0x00, }, // '%'
	{ 0x00, 0x00, 0x00, 0x06, 0x09, 0x09, 0x1e, 0x09, 0x09, 0x16, 0x00, 0x00, }, // '&'
	{ 0x00, 0x00, 0x00, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }, // "'"
	{ 0x00, 0x00, 0x00, 0x08, 0x04, 0x04, 0x04, 0x04, 0x04, 0x08, 0x00, 0x00, }, // '('
	{ 0x00, 0x00, 0x00, 0x02, 0x04, 0x04, 0x04, 0x04, 0x04, 0x02, 0x00, 0x00, }, // ')'
	{ 0x00, 0x00, 0x00, 0x00, 0x04, 0x15, 0x0e, 0x15, 0x04, 0x00, 0x00, 0x00, }, // '*'
	{ 0x00, 0x00, 0x00, 0x00, 0x04, 0x04, 0x1f, 0x04, 0x04, 0x00, 0x00, 0x00, }, // '+'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x04, 0x02, 0x00, }, // ','
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, }, // '-'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x04, 0x00, 0x00, }, // '.'
	{ 0x00, 0x00, 0x00, 0x10, 0x10, 0x08, 0x04, 0x02, 0x01, 0x01, 0x00, 0x00, }, // '/'
	{ 0x00, 0x00, 0x00, 0x00, 0x04, 0x04, 0x00, 0x00, 0x04, 0x04, 0x00, 0x00, }, // ':'
	{ 0x00, 0x00, 0x00, 0x00, 0x04, 0x04, 0x00, 0x00, 0x04, 0x04, 0x02, 0x00, }, // ';'
	{ 0x00, 0x00, 0x00, 0x00, 0x18, 0x06, 0x01, 0x06, 0x18, 0x00, 0x00, 0x00, }, // '<'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00, }, // '='
	{ 0x00, 0x00, 0x00, 0x00, 0x03, 0x0c, 0x10, 0x0c, 0x03, 0x00, 0x00, 0x00, }, // '>'
	{ 0x00, 0x00, 0x00, 0x0e, 0x11, 0x10, 0x08, 0x04, 0x00, 0x04, 0x00, 0x00, }, // '?'
	{ 0x00, 0x00, 0x00, 0x0e, 0x19, 0x15, 0x15, 0x19, 0x01, 0x0e, 0x00, 0x00, }, // '@'
	{ 0x00, 0x00, 0x00, 0x0e, 0x11, 0x11, 0x11, 0x1f, 0x11, 0x11, 0x00, 0x00, }, // 'A'
	{ 0x00, 0x00, 0x00, 0x0f, 0x11, 0x11, 0x0f, 0x11, 0x11, 0x0f, 0x00, 0x00, }, // 'B'
	{ 0x00, 0x00, 0x00, 0x0e, 0x11, 0x01, 0x01, 0x01, 0x11, 0x0e, 0x00, 0x00, }, // 'C'
	{ 0x00, 0x00, 0x00, 0x0f, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0f, 0x00, 0x00, }, // 'D'
	{ 0x00, 0x00, 0x00, 0x1f, 0x01, 0x01, 0x0f, 0x01, 0x01, 0x1f, 0x00, 0x00, }, // 'E'
	{ 0x00, 0x00, 0x00, 0x1f, 0x01, 0x01, 0x0f, 0x01, 0x01, 0x01, 0x00, 0x00, }, // 'F'
	{ 0x00, 0x00, 0x00, 0x0e, 0x11, 0x01, 0x1d, 0x11, 0x11, 0x0e, 0x00, 0x00, }, // 'G'
	{ 0x00, 0x00, 0x00, 0x11, 0x11, 0x11, 0x1f, 0x11, 0x11, 0x11, 0x00, 0x00, }, // 'H'
	{ 0x00, 0x00, 0x00, 0x1f, 0x04, 0x04, 0x04, 0x04, 0x04, 0x1f, 0x00, 0x00, }, // 'I'
	{ 0x00, 0x00, 0x00, 0x10, 0x10, 0x10, 0x10, 0x11, 0x11, 0x0e, 0x00, 0x00, }, // 'J'
	{ 0x00, 0x00, 0x00, 0x11, 0x09, 0x05, 0x03, 0x05, 0x09, 0x11, 0x00, 0x00, }, // 'K'
	{ 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x1f, 0x00, 0x00, }, // 'L'
	{ 0x00, 0x00, 0x00, 0x11, 0x1b, 0x15, 0x11, 0x11, 0x11, 0x11, 0x00, 0x00, }, // 'M'
	{ 0x00, 0x00, 0x00, 0x11, 0x11, 0x13, 0x15, 0x19, 0x11, 0x11, 0x00, 0x00, }, // 'N'
	{ 0x00, 0x00, 0x00, 0x0e, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0e, 0x00, 0x00, }, // 'O'
	{ 0x00, 0x00, 0x00, 0x0f, 0x11, 0x11, 0x0f, 0x01, 0x01, 0x01, 0x00, 0x00, }, // 'P'
	{ 0x00, 0x00, 0x00, 0x0e, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0e, 0x18, 0x00, }, // 'Q'
	{ 0x00, 0x00, 0x00, 0x0f, 0x11, 0x11, 0x0f, 0x11, 0x11, 0x11, 0x00, 0x00, }, // 'R'
	{ 0x00, 0x00, 0x00, 0x0e, 0x11, 0x01, 0x0e, 0x10, 0x11, 0x0e, 0x00, 0x00, }, // 'S'
	{ 0x00, 0x00, 0x00, 0x1f, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00, }, // 'T'
	{ 0x00, 0x00, 0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0e, 0x00, 0x00, }, // 'U'
	{ 0x00, 0x00, 0x00, 0x11, 0x11, 0x11, 0x11, 0x0a, 0x0a, 0x04, 0x00, 0x00, }, // 'V'
	{ 0x00, 0x00, 0x00, 0x11, 0x11, 0x11, 0x11, 0x15, 0x1b, 0x11, 0x00, 0x00, }, // 'W'
	{ 0x00, 0x00, 0x00, 0x11, 0x11, 0x0a, 0x04, 0x0a, 0x11, 0x11, 0x00, 0x00, }, // 'X'
	{ 0x00, 0x00, 0x00, 0x11, 0x11, 0x0a, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00, }, // 'Y'
	{ 0x00, 0x00, 0x00, 0x1f, 0x10, 0x08, 0x04, 0x02, 0x01, 0x1f, 0x00, 0x00, }, // 'Z'
	{ 0x00, 0x00, 0x00, 0x0c, 0x04, 0x04, 0x04, 0x04, 0x04, 0x0c, 0x00, 0x00, }, // '['
	{ 0x00, 0x00, 0x00, 0x01, 0x01, 0x02, 0x04, 0x08, 0x10, 0x10, 0x00, 0x00, }, // '\\'
	{ 0x00, 0x00, 0x00, 0x06, 0x04, 0x04, 0x04, 0x04, 0x04, 0x06, 0x00, 0x00, }, // ']'
	{ 0x00, 0x00, 0x00, 0x04, 0x0a, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }, // '^'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, }, // '_'
	{ 0x00, 0x00, 0x00, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }, // '`'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x11, 0x11, 0x11, 0x1e, 0x00, 0x00, }, // 'a'
	{ 0x00, 0x00, 0x00, 0x01, 0x01, 0x0f, 0x11, 0x11, 0x11, 0x0f, 0x00, 0x00, }, // 'b'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x11, 0x01, 0x11, 0x0e, 0x00, 0x00, }, // 'c'
	{ 0x00, 0x00, 0x00, 0x10, 0x10, 0x1e, 0x11, 0x11, 0x11, 0x1e, 0x00, 0x00, }, // 'd'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x11, 0x1f, 0x01, 0x0e, 0x00, 0x00, }, // 'e'
	{ 0x00, 0x00, 0x00, 0x0c, 0x12, 0x02, 0x0f, 0x02, 0x02, 0x02, 0x00, 0x00, }, // 'f'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x11, 0x11, 0x11, 0x1e, 0x10, 0x0e, }, // 'g'
	{ 0x00, 0x00, 0x00, 0x01, 0x01, 0x0f, 0x11, 0x11, 0x11, 0x11, 0x00, 0x00, }, // 'h'
	{ 0x00, 0x00, 0x00, 0x04, 0x00, 0x06, 0x04, 0x04, 0x04, 0x1f, 0x00, 0x00, }, // 'i'
	{ 0x00, 0x00, 0x00, 0x10, 0x00, 0x18, 0x10, 0x10, 0x10, 0x10, 0x11, 0x0e, }, // 'j'
	{ 0x00, 0x00, 0x00, 0x01, 0x01, 0x11, 0x09, 0x07, 0x09, 0x11, 0x00, 0x00, }, // 'k'
	{ 0x00, 0x00, 0x00, 0x03, 0x02, 0x02, 0x02, 0x02, 0x02, 0x1c, 0x00, 0x00, }, // 'l'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x15, 0x15, 0x15, 0x15, 0x00, 0x00, }, // 'm'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x11, 0x11, 0x11, 0x11, 0x00, 0x00, }, // 'n'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x11, 0x11, 0x11, 0x0e, 0x00, 0x00, }, // 'o'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x11, 0x11, 0x11, 0x0f, 0x01, 0x01, }, // 'p'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x11, 0x11, 0x11, 0x1e, 0x10, 0x10, }, // 'q'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x13, 0x01, 0x01, 0x01, 0x00, 0x00, }, // 'r'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x01, 0x0e, 0x10, 0x0f, 0x00, 0x00, }, // 's'
	{ 0x00, 0x00, 0x00, 0x02, 0x02, 0x0f, 0x02, 0x02, 0x02, 0x1c, 0x00, 0x00, }, // 't'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x11, 0x11, 0x11, 0x1e, 0x00, 0x00, }, // 'u'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x11, 0x11, 0x0a, 0x04, 0x00, 0x00, }, // 'v'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x11, 0x15, 0x15, 0x0a, 0x00, 0x00, }, // 'w'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x0a, 0x04, 0x0a, 0x11, 0x00, 0x00, }, // 'x'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x11, 0x11, 0x11, 0x1e, 0x10, 0x0e, }, // 'y'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x08, 0x04, 0x02, 0x1f, 0x00, 0x00, }, // 'z'
	{ 0x00, 0x00, 0x00, 0x08, 0x04, 0x04, 0x02, 0x04, 0x04, 0x08, 0x00, 0x00, }, // '{'
	{ 0x00, 0x00, 0x00, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00, }, // '|'
	{ 0x00, 0x00, 0x00, 0x02, 0x04, 0x04, 0x08, 0x04, 0x04, 0x02, 0x00, 0x00, }, // '}'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, }, // '~'
	{ 0x00, 0x00, 0x00, 0x04, 0x00, 0x04, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00, }, // '¡'
	{ 0x00, 0x00, 0x00, 0x04, 0x0e, 0x15, 0x05, 0x15, 0x0e, 0x04, 0x00, 0x00, }, // '¢'
	{ 0x00, 0x00, 0x00, 0x0c, 0x12, 0x02, 0x0f, 0x02, 0x02, 0x1f, 0x00, 0x00, }, // '£'
	{ 0x00, 0x00, 0x00, 0x00, 0x11, 0x0e, 0x0a, 0x0e, 0x11, 0x00, 0x00, 0x00, }, // '¤'
	{ 0x00, 0x00, 0x00, 0x11, 0x0a, 0x04, 0x1f, 0x04, 0x1f, 0x04, 0x00, 0x00, }, // '¥'
	{ 0x00, 0x00, 0x00, 0x04, 0x04, 0x04, 0x00, 0x04, 0x04, 0x04, 0x00, 0x00, }, // '¦'
	{ 0x00, 0x00, 0x00, 0x1e, 0x01, 0x0e, 0x11, 0x0e, 0x10, 0x0f, 0x00, 0x00, }, // '§'
	{ 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }, // '¨'
	{ 0x00, 0x00, 0x00, 0x0e, 0x1b, 0x15, 0x1d, 0x15, 0x1b, 0x0e, 0x00, 0x00, }, // '©'
	{ 0x00, 0x00, 0x00, 0x0e, 0x09, 0x09, 0x09, 0x0e, 0x00, 0x00, 0x00, 0x00, }, // 'ª'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x09, 0x12, 0x00, 0x00, 0x00, 0x00, }, // '«'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x10, 0x00, 0x00, 0x00, 0x00, }, // '¬'
	{ 0x00, 0x00, 0x00, 0x0e, 0x19, 0x15, 0x15, 0x19, 0x15, 0x0e, 0x00, 0x00, }, // '®'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, }, // '¯'
	{ 0x00, 0x00, 0x00, 0x06, 0x09, 0x09, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, }, // '°'
	{ 0x00, 0x00, 0x00, 0x04, 0x04, 0x1f, 0x04, 0x04, 0x00, 0x1f, 0x00, 0x00, }, // '±'
	{ 0x00, 0x00, 0x00, 0x03, 0x04, 0x02, 0x01, 0x07, 0x00, 0x00, 0x00, 0x00, }, // '²'
	{ 0x00, 0x00, 0x00, 0x03, 0x04, 0x02, 0x04, 0x03, 0x00, 0x00, 0x00, 0x00, }, // '³'
	{ 0x00, 0x00, 0x08, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }, // '´'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x11, 0x11, 0x11, 0x0f, 0x01, 0x01, }, // 'µ'
	{ 0x00, 0x00, 0x00, 0x1e, 0x17, 0x17, 0x17, 0x16, 0x14, 0x14, 0x00, 0x00, }, // '¶'
	{ 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }, // '·'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x08, 0x06, }, // '¸'
	{ 0x00, 0x00, 0x00, 0x02, 0x03, 0x02, 0x02, 0x07, 0x00, 0x00, 0x00, 0x00, }, // '¹'
	{ 0x00, 0x00, 0x00, 0x06, 0x09, 0x09, 0x09, 0x06, 0x00, 0x00, 0x00, 0x00, }, // 'º'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x12, 0x09, 0x00, 0x00, 0x00, 0x00, }, // '»'
	{ 0x00, 0x00, 0x00, 0x01, 0x09, 0x05, 0x02, 0x15, 0x1c, 0x10, 0x00, 0x00, }, // '¼'
	{ 0x00, 0x00, 0x00, 0x01, 0x09, 0x05, 0x0e, 0x11, 0x08, 0x1c, 0x00, 0x00, }, // '½'
	{ 0x00, 0x00, 0x00, 0x07, 0x16, 0x0f, 0x04, 0x16, 0x1d, 0x10, 0x00, 0x00, }, // '¾'
	{ 0x00, 0x00, 0x00, 0x04, 0x00, 0x04, 0x02, 0x01, 0x11, 0x0e, 0x00, 0x00, }, // '¿'
	{ 0x02, 0x04, 0x00, 0x0e, 0x11, 0x11, 0x1f, 0x11, 0x11, 0x11, 0x00, 0x00, }, // 'À'
	{ 0x08, 0x04, 0x00, 0x0e, 0x11, 0x11, 0x1f, 0x11, 0x11, 0x11, 0x00, 0x00, }, // 'Á'
	{ 0x04, 0x0a, 0x00, 0x0e, 0x11, 0x11, 0x1f, 0x11, 0x11, 0x11, 0x00, 0x00, }, // 'Â'
	{ 0x16, 0x09, 0x00, 0x0e, 0x11, 0x11, 0x1f, 0x11, 0x11, 0x11, 0x00, 0x00, }, // 'Ã'
	{ 0x00, 0x0a, 0x00, 0x0e, 0x11, 0x11, 0x1f, 0x11, 0x11, 0x11, 0x00, 0x00, }, // 'Ä'
	{ 0x04, 0x0a, 0x04, 0x0e, 0x11, 0x11, 0x1f, 0x11, 0x11, 0x11, 0x00, 0x00, }, // 'Å'
	{ 0x00, 0x00, 0x00, 0x1e, 0x05, 0x05, 0x1f, 0x05, 0x05, 0x1d, 0x00, 0x00, }, // 'Æ'
	{ 0x00, 0x00, 0x00, 0x0e, 0x11, 0x01, 0x01, 0x01, 0x11, 0x0e, 0x08, 0x06, }, // 'Ç'
	{ 0x02, 0x04, 0x00, 0x1f, 0x01, 0x01, 0x0f, 0x01, 0x01, 0x1f, 0x00, 0x00, }, // 'È'
	{ 0x08, 0x04, 0x00, 0x1f, 0x01, 0x01, 0x0f, 0x01, 0x01, 0x1f, 0x00, 0x00, }, // 'É'
	{ 0x04, 0x0a, 0x00, 0x1f, 0x01, 0x01, 0x0f, 0x01, 0x01, 0x1f, 0x00, 0x00, }, // 'Ê'
	{ 0x00, 0x0a, 0x00, 0x1f, 0x01, 0x01, 0x0f, 0x01, 0x01, 0x1f, 0x00, 0x00, }, // 'Ë'
	{ 0x02, 0x04, 0x00, 0x1f, 0x04, 0x04, 0x04, 0x04, 0x04, 0x1f, 0x00, 0x00, }, // 'Ì'
	{ 0x08, 0x04, 0x00, 0x1f, 0x04, 0x04, 0x04, 0x04, 0x04, 0x1f, 0x00, 0x00, }, // 'Í'
	{ 0x04, 0x0a, 0x00, 0x1f, 0x04, 0x04, 0x04, 0x04, 0x04, 0x1f, 0x00, 0x00, }, // 'Î'
	{ 0x00, 0x0a, 0x00, 0x1f, 0x04, 0x04, 0x04, 0x04, 0x04, 0x1f, 0x00, 0x00, }, // 'Ï'
	{ 0x00, 0x00, 0x00, 0x0f, 0x11, 0x11, 0x13, 0x11, 0x11, 0x0f, 0x00, 0x00, }, // 'Ð'
	{ 0x16, 0x09, 0x00, 0x11, 0x11, 0x13, 0x15, 0x19, 0x11, 0x11, 0x00, 0x00, }, // 'Ñ'
	{ 0x02, 0x04, 0x00, 0x0e, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0e, 0x00, 0x00, }, // 'Ò'
	{ 0x08, 0x04, 0x00, 0x0e, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0e, 0x00, 0x00, }, // 'Ó'
	{ 0x04, 0x0a, 0x00, 0x0e, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0e, 0x00, 0x00, }, // 'Ô'
	{ 0x16, 0x09, 0x00, 0x0e, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0e, 0x00, 0x00, }, // 'Õ'
	{ 0x00, 0x0a, 0x00, 0x0e, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0e, 0x00, 0x00, }, // 'Ö'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x04, 0x0a, 0x00, 0x00, 0x00, }, // '×'
	{ 0x00, 0x00, 0x00, 0x16, 0x09, 0x19, 0x15, 0x13, 0x12, 0x0d, 0x00, 0x00, }, // 'Ø'
	{ 0x02, 0x04, 0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0e, 0x00, 0x00, }, // 'Ù'
	{ 0x08, 0x04, 0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0e, 0x00, 0x00, }, // 'Ú'
	{ 0x04, 0x0a, 0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0e, 0x00, 0x00, }, // 'Û'
	{ 0x00, 0x0a, 0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0e, 0x00, 0x00, }, // 'Ü'
	{ 0x08, 0x04, 0x00, 0x11, 0x11, 0x0a, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00, }, // 'Ý'
	{ 0x00, 0x00, 0x00, 0x01, 0x0f, 0x11, 0x11, 0x11, 0x0f, 0x01, 0x00, 0x00, }, // 'Þ'
	{ 0x00, 0x00, 0x00, 0x06, 0x09, 0x09, 0x0d, 0x11, 0x11, 0x0d, 0x00, 0x00, }, // 'ß'
	{ 0x00, 0x00, 0x02, 0x04, 0x00, 0x1e, 0x11, 0x11, 0x11, 0x1e, 0x00, 0x00, }, // 'à'
	{ 0x00, 0x00, 0x08, 0x04, 0x00, 0x1e, 0x11, 0x11, 0x11, 0x1e, 0x00, 0x00, }, // 'á'
	{ 0x00, 0x00, 0x04, 0x0a, 0x00, 0x1e, 0x11, 0x11, 0x11, 0x1e, 0x00, 0x00, }, // 'â'
	{ 0x00, 0x00, 0x16, 0x09, 0x00, 0x1e, 0x11, 0x11, 0x11, 0x1e, 0x00, 0x00, }, // 'ã'
	{ 0x00, 0x00, 0x00, 0x0a, 0x00, 0x1e, 0x11, 0x11, 0x11, 0x1e, 0x00, 0x00, }, // 'ä'
	{ 0x00, 0x04, 0x0a, 0x04, 0x00, 0x1e, 0x11, 0x11, 0x11, 0x1e, 0x00, 0x00, }, // 'å'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x15, 0x1d, 0x05, 0x1e, 0x00, 0x00, }, // 'æ'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x11, 0x01, 0x11, 0x0e, 0x08, 0x06, }, // 'ç'
	{ 0x00, 0x00, 0x02, 0x04, 0x00, 0x0e, 0x11, 0x1f, 0x01, 0x0e, 0x00, 0x00, }, // 'è'
	{ 0x00, 0x00, 0x08, 0x04, 0x00, 0x0e, 0x11, 0x1f, 0x01, 0x0e, 0x00, 0x00, }, // 'é'
	{ 0x00, 0x00, 0x04, 0x0a, 0x00, 0x0e, 0x11, 0x1f, 0x01, 0x0e, 0x00, 0x00, }, // 'ê'
	{ 0x00, 0x00, 0x00, 0x0a, 0x00, 0x0e, 0x11, 0x1f, 0x01, 0x0e, 0x00, 0x00, }, // 'ë'
	{ 0x00, 0x00, 0x02, 0x04, 0x00, 0x06, 0x04, 0x04, 0x04, 0x1f, 0x00, 0x00, }, // 'ì'
	{ 0x00, 0x00, 0x08, 0x04, 0x00, 0x06, 0x04, 0x04, 0x04, 0x1f, 0x00, 0x00, }, // 'í'
	{ 0x00, 0x00, 0x04, 0x0a, 0x00, 0x06, 0x04, 0x04, 0x04, 0x1f, 0x00, 0x00, }, // 'î'
	{ 0x00, 0x00, 0x00, 0x0a, 0x00, 0x06, 0x04, 0x04, 0x04, 0x1f, 0x00, 0x00, }, // 'ï'
	{ 0x00, 0x00, 0x0e, 0x30, 0x18, 0x1e, 0x11, 0x11, 0x11, 0x0e, 0x00, 0x00, }, // 'ð'
	{ 0x00, 0x00, 0x16, 0x09, 0x00, 0x0f, 0x11, 0x11, 0x11, 0x11, 0x00, 0x00, }, // 'ñ'
	{ 0x00, 0x00, 0x02, 0x04, 0x00, 0x0e, 0x11, 0x11, 0x11, 0x0e, 0x00, 0x00, }, // 'ò'
	{ 0x00, 0x00, 0x08, 0x04, 0x00, 0x0e, 0x11, 0x11, 0x11, 0x0e, 0x00, 0x00, }, // 'ó'
	{ 0x00, 0x00, 0x04, 0x0a, 0x00, 0x0e, 0x11, 0x11, 0x11, 0x0e, 0x00, 0x00, }, // 'ô'
	{ 0x00, 0x00, 0x16, 0x09, 0x00, 0x0e, 0x11, 0x11, 0x11, 0x0e, 0x00, 0x00, }, // 'õ'
	{ 0x00, 0x00, 0x00, 0x0a, 0x00, 0x0e, 0x11, 0x11, 0x11, 0x0e, 0x00, 0x00, }, // 'ö'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x1f, 0x00, 0x04, 0x00, 0x00, }, // '÷'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x09, 0x15, 0x12, 0x0d, 0x00, 0x00, }, // 'ø'
	{ 0x00, 0x00, 0x02, 0x04, 0x00, 0x11, 0x11, 0x11, 0x11, 0x1e, 0x00, 0x00, }, // 'ù'
	{ 0x00, 0x00, 0x08, 0x04, 0x00, 0x11, 0x11, 0x11, 0x11, 0x1e, 0x00, 0x00, }, // 'ú'
	{ 0x00, 0x00, 0x04, 0x0a, 0x00, 0x11, 0x11, 0x11, 0x11, 0x1e, 0x00, 0x00, }, // 'û'
	{ 0x00, 0x00, 0x00, 0x0a, 0x00, 0x11, 0x11, 0x11, 0x11, 0x1e, 0x00, 0x00, }, // 'ü'
	{ 0x00, 0x00, 0x08, 0x04, 0x00, 0x11, 0x11, 0x11, 0x11, 0x1e, 0x10, 0x0e, }, // 'ý'
	{ 0x00, 0x00, 0x00, 0x01, 0x01, 0x0f, 0x11, 0x11, 0x11, 0x0f, 0x01, 0x01, }, // 'þ'
	{ 0x00, 0x00, 0x00, 0x0a, 0x00, 0x11, 0x11, 0x11, 0x11, 0x1e, 0x10, 0x0e, }, // 'ÿ'
	{ 0x00, 0x0e, 0x00, 0x0e, 0x11, 0x11, 0x1f, 0x11, 0x11, 0x11, 0x00, 0x00, }, // 'Ā'
	{ 0x00, 0x00, 0x00, 0x0e, 0x00, 0x1e, 0x11, 0x11, 0x11, 0x1e, 0x00, 0x00, }, // 'ā'
	{ 0x0a, 0x04, 0x00, 0x0e, 0x11, 0x11, 0x1f, 0x11, 0x11, 0x11, 0x00, 0x00, }, // 'Ă'
	{ 0x00, 0x00, 0x0a, 0x04, 0x00, 0x1e, 0x11, 0x11, 0x11, 0x1e, 0x00, 0x00, }, // 'ă'
	{ 0x00, 0x00, 0x00, 0x0e, 0x11, 0x11, 0x1f, 0x11, 0x11, 0x11, 0x08, 0x10, }, // 'Ą'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x11, 0x11, 0x11, 0x1e, 0x04, 0x18, }, // 'ą'
	{ 0x08, 0x04, 0x00, 0x0e, 0x11, 0x01, 0x01, 0x01, 0x11, 0x0e, 0x00, 0x00, }, // 'Ć'
	{ 0x00, 0x00, 0x08, 0x04, 0x00, 0x0e, 0x11, 0x01, 0x11, 0x0e, 0x00, 0x00, }, // 'ć'
	{ 0x04, 0x0a, 0x00, 0x0e, 0x11, 0x01, 0x01, 0x01, 0x11, 0x0e, 0x00, 0x00, }, // 'Ĉ'
	{ 0x00, 0x00, 0x04, 0x0a, 0x00, 0x0e, 0x11, 0x01, 0x11, 0x0e, 0x00, 0x00, }, // 'ĉ'
	{ 0x00, 0x04, 0x00, 0x0e, 0x11, 0x01, 0x01, 0x01, 0x11, 0x0e, 0x00, 0x00, }, // 'Ċ'
	{ 0x00, 0x00, 0x00, 0x04, 0x00, 0x0e, 0x11, 0x01, 0x11, 0x0e, 0x00, 0x00, }, // 'ċ'
	{ 0x0a, 0x04, 0x00, 0x0e, 0x11, 0x01, 0x01, 0x01, 0x11, 0x0e, 0x00, 0x00, }, // 'Č'
	{ 0x00, 0x00, 0x0a, 0x04, 0x00, 0x0e, 0x11, 0x01, 0x11, 0x0e, 0x00, 0x00, }, // 'č'
	{ 0x0a, 0x04, 0x00, 0x0f, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0f, 0x00, 0x00, }, // 'Ď'
	{ 0x00, 0x00, 0x50, 0x50, 0x10, 0x1e, 0x11, 0x11, 0x11, 0x1e, 0x00, 0x00, }, // 'ď'
	{ 0x00, 0x00, 0x00, 0x0f, 0x11, 0x11, 0x13, 0x11, 0x11, 0x0f, 0x00, 0x00, }, // 'Đ'
	{ 0x00, 0x00, 0x10, 0x3c, 0x10, 0x1e, 0x11, 0x11, 0x11, 0x1e, 0x00, 0x00, }, // 'đ'
	{ 0x00, 0x0e, 0x00, 0x1f, 0x01, 0x01, 0x07, 0x01, 0x01, 0x1f, 0x00, 0x00, }, // 'Ē'
	{ 0x00, 0x00, 0x00, 0x0e, 0x00, 0x0e, 0x11, 0x1f, 0x01, 0x0e, 0x00, 0x00, }, // 'ē'
	{ 0x0a, 0x04, 0x00, 0x1f, 0x01, 0x01, 0x07, 0x01, 0x01, 0x1f, 0x00, 0x00, }, // 'Ĕ'
	{ 0x00, 0x00, 0x0a, 0x04, 0x00, 0x0e, 0x11, 0x1f, 0x01, 0x0e, 0x00, 0x00, }, // 'ĕ'
	{ 0x00, 0x04, 0x00, 0x1f, 0x01, 0x01, 0x07, 0x01, 0x01, 0x1f, 0x00, 0x00, }, // 'Ė'
	{ 0x00, 0x00, 0x00, 0x04, 0x00, 0x0e, 0x11, 0x1f, 0x01, 0x0e, 0x00, 0x00, }, // 'ė'
	{ 0x00, 0x00, 0x00, 0x1f, 0x01, 0x01, 0x07, 0x01, 0x01, 0x1f, 0x04, 0x18, }, // 'Ę'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x11, 0x1f, 0x01, 0x1e, 0x04, 0x18, }, // 'ę'
	{ 0x00, 0x0e, 0x00, 0x1f, 0x01, 0x01, 0x07, 0x01, 0x01, 0x1f, 0x00, 0x00, }, // 'Ě'
	{ 0x00, 0x00, 0x00, 0x0a, 0x00, 0x0e, 0x11, 0x1f, 0x01, 0x0e, 0x00, 0x00, }, // 'ě'
	{ 0x04, 0x0a, 0x00, 0x0e, 0x11, 0x01, 0x1d, 0x11, 0x11, 0x0e, 0x00, 0x00, }, // 'Ĝ'
	{ 0x00, 0x00, 0x04, 0x0a, 0x00, 0x1e, 0x11, 0x11, 0x11, 0x1e, 0x10, 0x0e, }, // 'ĝ'
	{ 0x0a, 0x04, 0x00, 0x0e, 0x11, 0x01, 0x1d, 0x11, 0x11, 0x0e, 0x00, 0x00, }, // 'Ğ'
	{ 0x00, 0x00, 0x0a, 0x04, 0x00, 0x1e, 0x11, 0x11, 0x11, 0x1e, 0x10, 0x0e, }, // 'ğ'
	{ 0x00, 0x04, 0x00, 0x0e, 0x11, 0x01, 0x1d, 0x11, 0x11, 0x0e, 0x00, 0x00, }, // 'Ġ'
	{ 0x00, 0x00, 0x00, 0x04, 0x00, 0x1e, 0x11, 0x11, 0x11, 0x1e, 0x10, 0x0e, }, // 'ġ'
	{ 0x00, 0x00, 0x00, 0x0e, 0x11, 0x01, 0x1d, 0x11, 0x11, 0x0e, 0x08, 0x06, }, // 'Ģ'
	{ 0x00, 0x00, 0x08, 0x04, 0x00, 0x1e, 0x11, 0x11, 0x11, 0x1e, 0x10, 0x0e, }, // 'ģ'
	{ 0x04, 0x0a, 0x00, 0x11, 0x11, 0x11, 0x1f, 0x11, 0x11, 0x11, 0x00, 0x00, }, // 'Ĥ'
	{ 0x00, 0x00, 0x08, 0x15, 0x01, 0x0f, 0x11, 0x11, 0x11, 0x11, 0x00, 0x00, }, // 'ĥ'
	{ 0x00, 0x00, 0x00, 0x11, 0x3f, 0x11, 0x1f, 0x11, 0x11, 0x11, 0x00, 0x00, }, // 'Ħ'
	{ 0x00, 0x00, 0x00, 0x01, 0x03, 0x01, 0x0f, 0x11, 0x11, 0x11, 0x00, 0x00, }, // 'ħ'
	{ 0x16, 0x09, 0x00, 0x1f, 0x04, 0x04, 0x04, 0x04, 0x04, 0x1f, 0x00, 0x00, }, // 'Ĩ'
	{ 0x00, 0x00, 0x16, 0x09, 0x00, 0x06, 0x04, 0x04, 0x04, 0x1f, 0x00, 0x00, }, // 'ĩ'
	{ 0x00, 0x0e, 0x00, 0x1f, 0x04, 0x04, 0x04, 0x04, 0x04, 0x1f, 0x00, 0x00, }, // 'Ī'
	{ 0x00, 0x00, 0x00, 0x0e, 0x00, 0x06, 0x04, 0x04, 0x04, 0x1f, 0x00, 0x00, }, // 'ī'
	{ 0x0a, 0x04, 0x00, 0x1f, 0x04, 0x04, 0x04, 0x04, 0x04, 0x1f, 0x00, 0x00, }, // 'Ĭ'
	{ 0x00, 0x00, 0x0a, 0x04, 0x00, 0x06, 0x04, 0x04, 0x04, 0x1f, 0x00, 0x00, }, // 'ĭ'
	{ 0x00, 0x00, 0x00, 0x1f, 0x04, 0x04, 0x04, 0x04, 0x04, 0x1f, 0x04, 0x18, }, // 'Į'
	{ 0x00, 0x00, 0x00, 0x04, 0x00, 0x06, 0x04, 0x04, 0x04, 0x1f, 0x04, 0x18, }, // 'į'
	{ 0x16, 0x09, 0x00, 0x1f, 0x04, 0x04, 0x04, 0x04, 0x04, 0x1f, 0x00, 0x00, }, // 'İ'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x04, 0x04, 0x04, 0x1f, 0x00, 0x00, }, // 'ı'
	{ 0x00, 0x00, 0x00, 0x17, 0x12, 0x12, 0x12, 0x12, 0x12, 0x0f, 0x00, 0x00, }, // 'Ĳ'
	{ 0x00, 0x00, 0x00, 0x12, 0x00, 0x1b, 0x12, 0x12, 0x12, 0x1f, 0x10, 0x0e, }, // 'ĳ'
	{ 0x04, 0x0a, 0x00, 0x10, 0x10, 0x10, 0x10, 0x11, 0x11, 0x0e, 0x00, 0x00, }, // 'Ĵ'
	{ 0x00, 0x00, 0x10, 0x28, 0x00, 0x18, 0x10, 0x10, 0x10, 0x10, 0x11, 0x0e, }, // 'ĵ'
	{ 0x00, 0x00, 0x00, 0x11, 0x09, 0x05, 0x03, 0x05, 0x09, 0x11, 0x04, 0x04, }, // 'Ķ'
	{ 0x00, 0x00, 0x00, 0x01, 0x01, 0x11, 0x09, 0x07, 0x09, 0x11, 0x04, 0x04, }, // 'ķ'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x09, 0x07, 0x09, 0x11, 0x00, 0x00, }, // 'ĸ'
	{ 0x08, 0x04, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x1f, 0x00, 0x00, }, // 'Ĺ'
	{ 0x08, 0x04, 0x00, 0x1f, 0x04, 0x04, 0x04, 0x04, 0x04, 0x1f, 0x00, 0x00, }, // 'ĺ'
	{ 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x1f, 0x08, 0x06, }, // 'Ļ'
	{ 0x00, 0x00, 0x00, 0x1f, 0x04, 0x04, 0x04, 0x04, 0x04, 0x1f, 0x08, 0x06, }, // 'ļ'
	{ 0x00, 0x00, 0x00, 0x11, 0x11, 0x09, 0x01, 0x01, 0x01, 0x1f, 0x00, 0x00, }, // 'Ľ'
	{ 0x00, 0x00, 0x00, 0x13, 0x12, 0x0a, 0x02, 0x02, 0x02, 0x1c, 0x00, 0x00, }, // 'ľ'
	{ 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x09, 0x01, 0x01, 0x1f, 0x00, 0x00, }, // 'Ŀ'
	{ 0x00, 0x00, 0x00, 0x03, 0x02, 0x02, 0x0a, 0x02, 0x02, 0x1c, 0x00, 0x00, }, // 'ŀ'
	{ 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x1f, 0x00, 0x00, }, // 'Ł'
	{ 0x00, 0x00, 0x00, 0x03, 0x02, 0x02, 0x06, 0x03, 0x02, 0x1c, 0x00, 0x00, }, // 'ł'
	{ 0x08, 0x04, 0x00, 0x11, 0x11, 0x13, 0x15, 0x19, 0x11, 0x11, 0x00, 0x00, }, // 'Ń'
	{ 0x00, 0x00, 0x08, 0x04, 0x00, 0x0f, 0x11, 0x11, 0x11, 0x11, 0x00, 0x00, }, // 'ń'
	{ 0x00, 0x00, 0x00, 0x11, 0x11, 0x13, 0x15, 0x19, 0x11, 0x11, 0x04, 0x03, }, // 'Ņ'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x11, 0x11, 0x11, 0x11, 0x04, 0x03, }, // 'ņ'
	{ 0x0a, 0x04, 0x00, 0x11, 0x11, 0x13, 0x15, 0x19, 0x11, 0x11, 0x00, 0x00, }, // 'Ň'
	{ 0x00, 0x00, 0x0a, 0x04, 0x00, 0x0f, 0x11, 0x11, 0x11, 0x11, 0x00, 0x00, }, // 'ň'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x11, 0x11, 0x11, 0x11, 0x00, 0x00, }, // 'ŉ'
	{ 0x00, 0x00, 0x00, 0x11, 0x11, 0x13, 0x15, 0x19, 0x11, 0x11, 0x10, 0x0c, }, // 'Ŋ'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x11, 0x11, 0x11, 0x11, 0x10, 0x0c, }, // 'ŋ'
	{ 0x00, 0x0e, 0x00, 0x0e, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0e, 0x00, 0x00, }, // 'Ō'
	{ 0x00, 0x00, 0x00, 0x0e, 0x00, 0x0e, 0x11, 0x11, 0x11, 0x0e, 0x00, 0x00, }, // 'ō'
	{ 0x0a, 0x04, 0x00, 0x0e, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0e, 0x00, 0x00, }, // 'Ŏ'
	{ 0x00, 0x00, 0x0a, 0x04, 0x00, 0x0e, 0x11, 0x11, 0x11, 0x0e, 0x00, 0x00, }, // 'ŏ'
	{ 0x14, 0x0a, 0x00, 0x0e, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0e, 0x00, 0x00, }, // 'Ő'
	{ 0x00, 0x00, 0x14, 0x0a, 0x00, 0x0e, 0x11, 0x11, 0x11, 0x0e, 0x00, 0x00, }, // 'ő'
	{ 0x00, 0x00, 0x00, 0x1e, 0x05, 0x05, 0x1d, 0x05, 0x05, 0x1e, 0x00, 0x00, }, // 'Œ'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x15, 0x1d, 0x05, 0x0e, 0x00, 0x00, }, // 'œ'
	{ 0x08, 0x04, 0x00, 0x0f, 0x11, 0x11, 0x0f, 0x11, 0x11, 0x11, 0x00, 0x00, }, // 'Ŕ'
	{ 0x00, 0x00, 0x08, 0x04, 0x00, 0x0d, 0x13, 0x01, 0x01, 0x01, 0x00, 0x00, }, // 'ŕ'
	{ 0x00, 0x00, 0x00, 0x0f, 0x11, 0x11, 0x0f, 0x11, 0x11, 0x11, 0x04, 0x03, }, // 'Ŗ'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x13, 0x01, 0x01, 0x01, 0x04, 0x03, }, // 'ŗ'
	{ 0x0a, 0x04, 0x00, 0x0f, 0x11, 0x11, 0x0f, 0x11, 0x11, 0x11, 0x00, 0x00, }, // 'Ř'
	{ 0x00, 0x00, 0x0a, 0x04, 0x00, 0x0d, 0x13, 0x01, 0x01, 0x01, 0x00, 0x00, }, // 'ř'
	{ 0x08, 0x04, 0x00, 0x0e, 0x11, 0x01, 0x0e, 0x10, 0x11, 0x0e, 0x00, 0x00, }, // 'Ś'
	{ 0x00, 0x00, 0x08, 0x04, 0x00, 0x1e, 0x01, 0x0e, 0x10, 0x0f, 0x00, 0x00, }, // 'ś'
	{ 0x04, 0x0a, 0x00, 0x0e, 0x11, 0x01, 0x0e, 0x10, 0x11, 0x0e, 0x00, 0x00, }, // 'Ŝ'
	{ 0x00, 0x00, 0x04, 0x0a, 0x00, 0x1e, 0x01, 0x0e, 0x10, 0x0f, 0x00, 0x00, }, // 'ŝ'
	{ 0x00, 0x00, 0x00, 0x0e, 0x11, 0x01, 0x0e, 0x10, 0x11, 0x0e, 0x04, 0x03, }, // 'Ş'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x01, 0x0e, 0x10, 0x0f, 0x04, 0x03, }, // 'ş'
	{ 0x0a, 0x04, 0x00, 0x0e, 0x11, 0x01, 0x0e, 0x10, 0x11, 0x0e, 0x00, 0x00, }, // 'Š'
	{ 0x00, 0x00, 0x0a, 0x04, 0x00, 0x1e, 0x01, 0x0e, 0x10, 0x0f, 0x00, 0x00, }, // 'š'
	{ 0x00, 0x00, 0x00, 0x1f, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x03, }, // 'Ţ'
	{ 0x00, 0x00, 0x00, 0x02, 0x02, 0x0f, 0x02, 0x02, 0x02, 0x1c, 0x08, 0x06, }, // 'ţ'
	{ 0x0a, 0x04, 0x00, 0x1f, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00, }, // 'Ť'
	{ 0x00, 0x00, 0x08, 0x0a, 0x02, 0x0f, 0x02, 0x02, 0x02, 0x1c, 0x00, 0x00, }, // 'ť'
	{ 0x00, 0x00, 0x00, 0x1f, 0x04, 0x0e, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00, }, // 'Ŧ'
	{ 0x00, 0x00, 0x00, 0x02, 0x0f, 0x02, 0x0f, 0x02, 0x02, 0x1c, 0x00, 0x00, }, // 'ŧ'
	{ 0x16, 0x09, 0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0e, 0x00, 0x00, }, // 'Ũ'
	{ 0x00, 0x00, 0x16, 0x09, 0x00, 0x11, 0x11, 0x11, 0x11, 0x1e, 0x00, 0x00, }, // 'ũ'
	{ 0x00, 0x0e, 0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0e, 0x00, 0x00, }, // 'Ū'
	{ 0x00, 0x00, 0x00, 0x0e, 0x00, 0x11, 0x11, 0x11, 0x11, 0x1e, 0x00, 0x00, }, // 'ū'
	{ 0x0a, 0x04, 0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0e, 0x00, 0x00, }, // 'Ŭ'
	{ 0x00, 0x00, 0x0a, 0x04, 0x00, 0x11, 0x11, 0x11, 0x11, 0x1e, 0x00, 0x00, }, // 'ŭ'
	{ 0x0a, 0x04, 0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0e, 0x00, 0x00, }, // 'Ů'
	{ 0x00, 0x04, 0x0a, 0x04, 0x00, 0x11, 0x11, 0x11, 0x11, 0x1e, 0x00, 0x00, }, // 'ů'
	{ 0x14, 0x0a, 0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0e, 0x00, 0x00, }, // 'Ű'
	{ 0x00, 0x00, 0x14, 0x0a, 0x00, 0x11, 0x11, 0x11, 0x11, 0x1e, 0x00, 0x00, }, // 'ű'
	{ 0x00, 0x00, 0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0e, 0x04, 0x18, }, // 'Ų'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x11, 0x11, 0x11, 0x1e, 0x04, 0x18, }, // 'ų'
	{ 0x04, 0x0a, 0x00, 0x11, 0x11, 0x11, 0x11, 0x15, 0x1b, 0x11, 0x00, 0x00, }, // 'Ŵ'
	{ 0x00, 0x00, 0x04, 0x0a, 0x00, 0x11, 0x11, 0x15, 0x15, 0x0a, 0x00, 0x00, }, // 'ŵ'
	{ 0x04, 0x0a, 0x00, 0x11, 0x11, 0x0a, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00, }, // 'Ŷ'
	{ 0x00, 0x00, 0x04, 0x0a, 0x00, 0x11, 0x11, 0x11, 0x11, 0x1e, 0x10, 0x0e, }, // 'ŷ'
	{ 0x00, 0x0a, 0x00, 0x11, 0x11, 0x0a, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00, }, // 'Ÿ'
	{ 0x08, 0x04, 0x00, 0x1f, 0x10, 0x08, 0x04, 0x02, 0x01, 0x1f, 0x00, 0x00, }, // 'Ź'
	{ 0x00, 0x00, 0x08, 0x04, 0x00, 0x1f, 0x08, 0x04, 0x02, 0x1f, 0x00, 0x00, }, // 'ź'
	{ 0x00, 0x04, 0x00, 0x1f, 0x10, 0x08, 0x04, 0x02, 0x01, 0x1f, 0x00, 0x00, }, // 'Ż'
	{ 0x00, 0x00, 0x00, 0x04, 0x00, 0x1f, 0x08, 0x04, 0x02, 0x1f, 0x00, 0x00, }, // 'ż'
	{ 0x0a, 0x04, 0x00, 0x1f, 0x10, 0x08, 0x04, 0x02, 0x01, 0x1f, 0x00, 0x00, }, // 'Ž'
	{ 0x00, 0x00, 0x0a, 0x04, 0x00, 0x1f, 0x08, 0x04, 0x02, 0x1f, 0x00, 0x00, }, // 'ž'
	{ 0x00, 0x0a, 0x00, 0x1f, 0x01, 0x01, 0x0f, 0x01, 0x01, 0x1f, 0x00, 0x00, }, // 'Ё'
	{ 0x00, 0x00, 0x00, 0x0e, 0x11, 0x11, 0x11, 0x1f, 0x11, 0x11, 0x00, 0x00, }, // 'А'
	{ 0x00, 0x00, 0x00, 0x1f, 0x01, 0x01, 0x0f, 0x11, 0x11, 0x0f, 0x00, 0x00, }, // 'Б'
	{ 0x00, 0x00, 0x00, 0x0f, 0x11, 0x11, 0x0f, 0x11, 0x11, 0x0f, 0x00, 0x00, }, // 'В'
	{ 0x00, 0x00, 0x00, 0x1f, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, }, // 'Г'
	{ 0x00, 0x00, 0x00, 0x0c, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x1f, 0x11, 0x00, }, // 'Д'
	{ 0x00, 0x00, 0x00, 0x1f, 0x01, 0x01, 0x0f, 0x01, 0x01, 0x1f, 0x00, 0x00, }, // 'Е'
	{ 0x00, 0x00, 0x00, 0x15, 0x15, 0x15, 0x0e, 0x15, 0x15, 0x15, 0x00, 0x00, }, // 'Ж'
	{ 0x00, 0x00, 0x00, 0x0e, 0x11, 0x10, 0x0e, 0x10, 0x11, 0x0e, 0x00, 0x00, }, // 'З'
	{ 0x00, 0x00, 0x00, 0x11, 0x11, 0x19, 0x15, 0x13, 0x11, 0x11, 0x00, 0x00, }, // 'И'
	{ 0x00, 0x0a, 0x04, 0x11, 0x11, 0x19, 0x15, 0x13, 0x11, 0x11, 0x00, 0x00, }, // 'Й'
	{ 0x00, 0x00, 0x00, 0x19, 0x05, 0x05, 0x03, 0x05, 0x09, 0x11, 0x00, 0x00, }, // 'К'
	{ 0x00, 0x00, 0x00, 0x1e, 0x12, 0x12, 0x12, 0x12, 0x12, 0x11, 0x00, 0x00, }, // 'Л'
	{ 0x00, 0x00, 0x00, 0x11, 0x1b, 0x15, 0x11, 0x11, 0x11, 0x11, 0x00, 0x00, }, // 'М'
	{ 0x00, 0x00, 0x00, 0x11, 0x11, 0x11, 0x1f, 0x11, 0x11, 0x11, 0x00, 0x00, }, // 'Н'
	{ 0x00, 0x00, 0x00, 0x0e, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0e, 0x00, 0x00, }, // 'О'
	{ 0x00, 0x00, 0x00, 0x1f, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x00, 0x00, }, // 'П'
	{ 0x00, 0x00, 0x00, 0x0f, 0x11, 0x11, 0x0f, 0x01, 0x01, 0x01, 0x00, 0x00, }, // 'Р'
	{ 0x00, 0x00, 0x00, 0x0e, 0x11, 0x01, 0x01, 0x01, 0x11, 0x0e, 0x00, 0x00, }, // 'С'
	{ 0x00, 0x00, 0x00, 0x1f, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00, }, // 'Т'
	{ 0x00, 0x00, 0x00, 0x11, 0x11, 0x11, 0x11, 0x1e, 0x10, 0x0e, 0x00, 0x00, }, // 'У'
	{ 0x00, 0x00, 0x00, 0x04, 0x0e, 0x15, 0x15, 0x15, 0x0e, 0x04, 0x00, 0x00, }, // 'Ф'
	{ 0x00, 0x00, 0x00, 0x11, 0x11, 0x0a, 0x04, 0x0a, 0x11, 0x11, 0x00, 0x00, }, // 'Х'
	{ 0x00, 0x00, 0x00, 0x00, 0x09, 0x09, 0x09, 0x09, 0x09, 0x1f, 0x10, 0x00, }, // 'Ц'
	{ 0x00, 0x00, 0x00, 0x11, 0x11, 0x11, 0x1e, 0x10, 0x10, 0x10, 0x00, 0x00, }, // 'Ч'
	{ 0x00, 0x00, 0x00, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x1f, 0x00, 0x00, }, // 'Ш'
	{ 0x00, 0x00, 0x00, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x1f, 0x10, 0x00, }, // 'Щ'
	{ 0x00, 0x00, 0x00, 0x00, 0x03, 0x02, 0x0e, 0x12, 0x12, 0x0e, 0x00, 0x00, }, // 'Ъ'
	{ 0x00, 0x00, 0x00, 0x00, 0x11, 0x11, 0x13, 0x15, 0x15, 0x13, 0x00, 0x00, }, // 'Ы'
	{ 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x0f, 0x11, 0x11, 0x0f, 0x00, 0x00, }, // 'Ь'
	{ 0x00, 0x00, 0x00, 0x0e, 0x11, 0x10, 0x1c, 0x10, 0x11, 0x0e, 0x00, 0x00, }, // 'Э'
	{ 0x00, 0x00, 0x00, 0x09, 0x15, 0x15, 0x17, 0x15, 0x15, 0x09, 0x00, 0x00, }, // 'Ю'
	{ 0x00, 0x00, 0x00, 0x00, 0x1e, 0x11, 0x11, 0x1e, 0x11, 0x11, 0x00, 0x00, }, // 'Я'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x10, 0x1e, 0x11, 0x1e, 0x00, 0x00, }, // 'а'
	{ 0x00, 0x00, 0x00, 0x1e, 0x01, 0x0d, 0x13, 0x11, 0x11, 0x0e, 0x00, 0x00, }, // 'б'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x11, 0x0f, 0x11, 0x0f, 0x00, 0x00, }, // 'в'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, }, // 'г'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x0a, 0x0a, 0x0a, 0x1f, 0x11, 0x00, }, // 'д'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x11, 0x1f, 0x01, 0x0e, 0x00, 0x00, }, // 'е'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x0e, 0x04, 0x0e, 0x15, 0x00, 0x00, }, // 'ж'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x09, 0x04, 0x09, 0x06, 0x00, 0x00, }, // 'з'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x19, 0x15, 0x13, 0x11, 0x00, 0x00, }, // 'и'
	{ 0x00, 0x00, 0x00, 0x0a, 0x04, 0x11, 0x19, 0x15, 0x13, 0x11, 0x00, 0x00, }, // 'й'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x09, 0x07, 0x09, 0x11, 0x00, 0x00, }, // 'к'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x12, 0x12, 0x12, 0x11, 0x00, 0x00, }, // 'л'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x1b, 0x15, 0x11, 0x11, 0x00, 0x00, }, // 'м'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x11, 0x1f, 0x11, 0x11, 0x00, 0x00, }, // 'н'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x11, 0x11, 0x11, 0x0e, 0x00, 0x00, }, // 'о'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x11, 0x11, 0x11, 0x11, 0x00, 0x00, }, // 'п'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x13, 0x11, 0x11, 0x0f, 0x01, 0x01, }, // 'р'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x11, 0x01, 0x11, 0x0e, 0x00, 0x00, }, // 'с'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00, }, // 'т'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x11, 0x11, 0x11, 0x1e, 0x10, 0x0e, }, // 'у'
	{ 0x00, 0x00, 0x00, 0x04, 0x04, 0x0e, 0x15, 0x15, 0x15, 0x0e, 0x04, 0x04, }, // 'ф'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x0a, 0x04, 0x0a, 0x11, 0x00, 0x00, }, // 'х'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x09, 0x09, 0x09, 0x1f, 0x10, 0x00, }, // 'ц'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x11, 0x11, 0x1e, 0x10, 0x00, 0x00, }, // 'ч'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x15, 0x15, 0x15, 0x1f, 0x00, 0x00, }, // 'ш'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x15, 0x15, 0x15, 0x1f, 0x10, 0x00, }, // 'щ'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x02, 0x0e, 0x12, 0x0e, 0x00, 0x00, }, // 'ъ'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x11, 0x13, 0x15, 0x13, 0x00, 0x00, }, // 'ы'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x0f, 0x11, 0x0f, 0x00, 0x00, }, // 'ь'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x11, 0x1c, 0x11, 0x0e, 0x00, 0x00, }, // 'э'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x15, 0x17, 0x15, 0x09, 0x00, 0x00, }, // 'ю'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x11, 0x11, 0x1e, 0x11, 0x00, 0x00, }, // 'я'
	{ 0x00, 0x00, 0x00, 0x0a, 0x00, 0x0e, 0x11, 0x1f, 0x01, 0x0e, 0x00, 0x00, }, // 'ё'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, }, // '—'
	{ 0x00, 0x00, 0x00, 0x08, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }, // '’'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x15, 0x00, 0x00, }, // '…'
	{ 0x00, 0x00, 0x00, 0x0c, 0x12, 0x07, 0x02, 0x07, 0x12, 0x0c, 0x00, 0x00, }, // '€'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x1e, 0x1f, 0x1e, 0x04, 0x00, 0x00, }, // '←'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x0e, 0x1f, 0x0e, 0x0e, 0x00, 0x00, }, // '↑'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x0f, 0x1f, 0x0f, 0x04, 0x00, 0x00, }, // '→'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x0e, 0x1f, 0x0e, 0x04, 0x00, 0x00, }, // '↓'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }, // ' '
};

u32 monogram_ascii_to_idx[127] = {
	0xFFFF,
	0xFFFF,
	0xFFFF,
	0xFFFF,
	0xFFFF,
	0xFFFF,
	0xFFFF,
	0xFFFF,
	0xFFFF,
	0xFFFF,
	0xFFFF,
	0xFFFF,
	0xFFFF,
	0xFFFF,
	0xFFFF,
	0xFFFF,
	0xFFFF,
	0xFFFF,
	0xFFFF,
	0xFFFF,
	0xFFFF,
	0xFFFF,
	0xFFFF,
	0xFFFF,
	0xFFFF,
	0xFFFF,
	0xFFFF,
	0xFFFF,
	0xFFFF,
	0xFFFF,
	0xFFFF,
	0xFFFF,
	389, // 0x20 ' '
	10, // 0x21 '!'
	11, // 0x22 '"'
	12, // 0x23 '#'
	13, // 0x24 '$'
	14, // 0x25 '%'
	15, // 0x26 '&'
	16, // 0x27 '''
	17, // 0x28 '('
	18, // 0x29 ')'
	19, // 0x2a '*'
	20, // 0x2b '+'
	21, // 0x2c ','
	22, // 0x2d '-'
	23, // 0x2e '.'
	24, // 0x2f '/'
	0, // 0x30 '0'
	1, // 0x31 '1'
	2, // 0x32 '2'
	3, // 0x33 '3'
	4, // 0x34 '4'
	5, // 0x35 '5'
	6, // 0x36 '6'
	7, // 0x37 '7'
	8, // 0x38 '8'
	9, // 0x39 '9'
	25, // 0x3a ':'
	26, // 0x3b ';'
	27, // 0x3c '<'
	28, // 0x3d '='
	29, // 0x3e '>'
	30, // 0x3f '?'
	31, // 0x40 '@'
	32, // 0x41 'A'
	33, // 0x42 'B'
	34, // 0x43 'C'
	35, // 0x44 'D'
	36, // 0x45 'E'
	37, // 0x46 'F'
	38, // 0x47 'G'
	39, // 0x48 'H'
	40, // 0x49 'I'
	41, // 0x4a 'J'
	42, // 0x4b 'K'
	43, // 0x4c 'L'
	44, // 0x4d 'M'
	45, // 0x4e 'N'
	46, // 0x4f 'O'
	47, // 0x50 'P'
	48, // 0x51 'Q'
	49, // 0x52 'R'
	50, // 0x53 'S'
	51, // 0x54 'T'
	52, // 0x55 'U'
	53, // 0x56 'V'
	54, // 0x57 'W'
	55, // 0x58 'X'
	56, // 0x59 'Y'
	57, // 0x5a 'Z'
	58, // 0x5b '['
	59, // 0x5c '\'
	60, // 0x5d ']'
	61, // 0x5e '^'
	62, // 0x5f '_'
	63, // 0x60 '`'
	64, // 0x61 'a'
	65, // 0x62 'b'
	66, // 0x63 'c'
	67, // 0x64 'd'
	68, // 0x65 'e'
	69, // 0x66 'f'
	70, // 0x67 'g'
	71, // 0x68 'h'
	72, // 0x69 'i'
	73, // 0x6a 'j'
	74, // 0x6b 'k'
	75, // 0x6c 'l'
	76, // 0x6d 'm'
	77, // 0x6e 'n'
	78, // 0x6f 'o'
	79, // 0x70 'p'
	80, // 0x71 'q'
	81, // 0x72 'r'
	82, // 0x73 's'
	83, // 0x74 't'
	84, // 0x75 'u'
	85, // 0x76 'v'
	86, // 0x77 'w'
	87, // 0x78 'x'
	88, // 0x79 'y'
	89, // 0x7a 'z'
	90, // 0x7b '{'
	91, // 0x7c '|'
	92, // 0x7d '}'
	93, // 0x7e '~'
};

void console_redraw_commit()
{
	console_redraw_line(line_idx);

	for (u32 row = 0; row < NUM_ROWS; ++row)
	{
		for (int col = 0; col < NUM_COLS; ++col)
		{
			char ch = text[row][col];

			if (ch == 0) continue;

			console_draw_char(ch, col, row);
		}
	}

	u64 t = time_current_ms();
	bool cursor_on = (t / 400) % 2;

	if (cursor_on)
	{
		console_draw_char('_', col_idx, line_idx);
	}

	window_draw_frame(0, frame_buffer);
}

size_t console_get_line_pos(size_t line_num)
{
	return margin + char_height*line_num;
}

void console_redraw_line(size_t start_y)
{
	size_t start = console_get_line_pos(start_y);
	size_t end = console_get_line_pos(start_y + 1) + FONT_MONOGRAM_HEIGHT;

	for(u64 y = start; y < end; ++y) 
		memset32(((u32*)frame_buffer) + FRAME_WIDTH * y, blue, console_width);
}

void console_redraw_all_text()
{

	for(size_t y = 0; y < FRAME_HEIGHT; ++y)
	  memset32(((u32*)frame_buffer) + FRAME_WIDTH * y, blue, console_width);

}

void console_make_space()
{
	for(size_t cur=0; cur < (NUM_ROWS-1); ++cur)
	  memcpy(text[cur], text[cur+1], NUM_COLS);
	memset(text[NUM_ROWS-1], 0, NUM_COLS);
	col_idx=0;
	console_redraw_all_text();
}

void console_newline()
{
	if (line_idx + 1 < NUM_ROWS)
	{
		console_redraw_line(line_idx);
		line_idx = line_idx + 1;
		col_idx = 0;
	}
	else console_make_space();
}

void console_putchar(char ch)
{
	text[line_idx][col_idx] = ch;

	if (col_idx + 1 < NUM_COLS)
	{
		col_idx = col_idx + 1;
	}
	else if (line_idx + 1 < NUM_ROWS)
	{
		size_t old_col_idx = col_idx;
		console_newline();
		if(old_col_idx >= NUM_COLS)
			col_idx = col_idx + 1;
	}
	else
	{
		console_make_space();
		if(min_line_idx > 0)
			min_line_idx = min_line_idx - 1;
	}
}

void console_puts(u8* ch)
{
	while((*ch) != 0)
	{
		console_putchar(*ch);
		++ch;
	}
}

char console_input_buff[20] ;
void console_print_i64(i64 n)
{
	memset(console_input_buff, 0, sizeof(console_input_buff));
	u8 buff_start = 18;
	u8 is_neg =  0;

	if(0 > n)
	{
		is_neg = 1;
		n = -n;
	}
	else if (n == 0)
	{
		console_input_buff[buff_start] = 48;
		--buff_start;
	}

	for(; n!=0; --buff_start)
	{
		console_input_buff[buff_start] = (n % 10) + 48;
		n = n / 10;
	}

	if (is_neg)
	{
		DEBUG("setting neg sign\n");
		console_input_buff[buff_start] = '-';
		--buff_start;
	}

	console_puts(console_input_buff+(buff_start+1));
}

void console_draw_char(char ch, size_t row_num, size_t col_num)
{
	row_num = margin + char_width * row_num;
	col_num = console_get_line_pos(col_num);
	u8 scale = 3;
	u32 char_idx = monogram_ascii_to_idx[ch];

	u32* d = get_point_ptr((u32*)frame_buffer, FRAME_WIDTH, row_num, col_num);

	for (u64 y = 0; y < FONT_MONOGRAM_HEIGHT; ++y)
	{
		u8 pixel_bits = font_monogram_data[char_idx][y];
		for (u8 i = 0; i < scale; ++i)
		{
			u64 x = 0;
			u8 pb = pixel_bits;

			while (pb)
			{
				memset32(d + x, blue, scale);
				if (pb & 1) memset32(d + x, 0xFFFFFF, scale);
				x = x + scale;
				pb = pb >> 1;
			}

			d = d + FRAME_WIDTH;
		}
	}
}

//===========================================================================
/* CANVAS */

#define CANVAS_PLOT_POINT_SIZE 5

u8 canvas_plot(u64 x, u64 y, u64 color)
{
	TRY(canvas_coord_gaurd(x, y));
	u32* p = get_point_ptr((u32*)frame_buffer, FRAME_WIDTH, x, y);

	for(u32 y = 0; y < CANVAS_PLOT_POINT_SIZE; ++y)
	{
		memset32(p + console_width, color, CANVAS_PLOT_POINT_SIZE);
		p = p + FRAME_WIDTH;
	}
	return 0;
}

u8 canvas_coord_gaurd(u64 x, u64 y)
{
	if((x + console_width) > FRAME_WIDTH)
	{
		console_error("The given X coordinate exceeds the size of the canvas width");
		return 1;
	}
	if(y > FRAME_HEIGHT)
	{
		console_error("The given y coordinate exceeds the size of the canvas height");
		return 1;
	}

	return 0;
}

void canvas_clear()
{
	memset32(frame_buffer, 0xFFFFFF, sizeof(frame_buffer) / sizeof(u32));
}


//===========================================================================
/* INTERP */

char vm_command_text_buffer[1024];
size_t vm_command_text_buffer_cursor =0;
size_t vm_command_text_buffer_read = 0; 

void vm_command_text_buffer_clear()
{
	memset(vm_command_text_buffer, 0, sizeof(vm_command_text_buffer));
	vm_command_text_buffer_read = 0;
	vm_command_text_buffer_cursor = 0;
}

void vm_command_text_buffer_backspace()
{
	if(vm_command_text_buffer_cursor > 0)
	{
		vm_command_text_buffer[vm_command_text_buffer_cursor] = 0;
		--vm_command_text_buffer_cursor;
	}
}

#define OP_PUSH 0
// pops the top of the stack, assigns the value to the var
#define OP_SET_VAR 1        
// pushes a var value to the stack
#define OP_GET_VAR 2        

#define OP_JUMP 3          // jumps to instructions within a command
#define OP_JUMP_IF 4
#define OP_JUMP_IF_NOT 5

// binary arth ops pop 2 vals from the stack, push the result to the stack
#define OP_ADD 6            
#define OP_SUB 7
#define OP_MULT 8
#define OP_DIV 9

#define OP_GT 10
#define OP_LT 11
#define OP_GT_EQ 12
#define OP_LT_EQ 13

#define OP_EQ 14
#define OP_NOT_EQ 15

#define OP_PRINT_INT 16

#define OP_GOTO 17 // Jumps to a command, as opposed to jumping to instructions as OP_JUMP does

#define OP_PLOT 18 // draws a pixel at x, y
#define OP_LINE 19
#define OP_CLEAN 20
#define OP_HELP 21

#define OP_HALT 22 // stops execution


// Maps symbols to var positions
size_t vm_intern_capacity = 1024;
u64** vm_intern_buffer;

// Linkedlist containing sorterd commands
// Each command is a list of instructions
// represented this way in order to insert new commands in between old ones
#define VM_COMMANDS_NUM 0
#define VM_COMMANDS_CAPACITY 1
#define VM_COMMANDS_CUR 2
#define VM_COMMANDS_NEXT 3
#define VM_COMMANDS_INSTS_BUFFER 4

u64** vm_commands_selected = NULL;
u64** vm_commands_root = NULL;

// Vector containing variable values
size_t vm_vars_allocated = 0;
i64 vm_vars[1024];

// Stack that can be pushed to and poped from
size_t vm_stack_cursor = 0;
i64 vm_stack[1024];

u64** vm_commands_alloc(u64 num)
{
	size_t capacity = 256;
	size_t meta_data_size = sizeof(u64*)*5;
	size_t inst_buffer_size = sizeof(u64)*capacity;

	u64** command_meta = (u64**)malloc(meta_data_size);
	NULLGAURD(command_meta);
	memset(command_meta, 0, meta_data_size);
	u64* inst_buffer = (u64*) malloc(inst_buffer_size);
	NULLGAURD(inst_buffer);
	memset(inst_buffer, 0, inst_buffer_size);
	command_meta[VM_COMMANDS_CAPACITY] = (u64*)capacity;
	command_meta[VM_COMMANDS_NUM] = (u64*)num;
	command_meta[VM_COMMANDS_INSTS_BUFFER] = inst_buffer;
	return command_meta;
}

u64** vm_command_find(u64 num)
{
	for(u64** cur_cmd = vm_commands_root; cur_cmd != 0; cur_cmd = (u64**)cur_cmd[VM_COMMANDS_NEXT])
	{
		u64 cur_cmd_num = (u64)cur_cmd[VM_COMMANDS_NUM];
		if (cur_cmd_num == num) return cur_cmd;
	}
	return 0;
}

void vm_command_free(u64** cmd)
{
	free((void*)cmd[VM_COMMANDS_INSTS_BUFFER]);
	free((void*) cmd);
}

u64** vm_command_create(u64 num)
{

	u64** new_cmd = vm_commands_alloc(num);
	NULLGAURD(new_cmd);

	if(vm_commands_root == NULL)
	{ // initialize
		DEBUG("Init commands\n");
		new_cmd[VM_COMMANDS_NEXT] = (u64*)vm_commands_root;
		vm_commands_root = new_cmd;
		return new_cmd;
	} 

	DEBUG("Finding command\n");
	u64** prev_cmd = 0;
	for(u64** cur_cmd = vm_commands_root;; cur_cmd = (u64**)cur_cmd[VM_COMMANDS_NEXT])
	{
		if(cur_cmd == NULL)
		{
			DEBUG("Inserting command at the end");
			prev_cmd[VM_COMMANDS_NEXT] = (u64*)new_cmd;
			break;
		}
		u64 cur_cmd_num = (u64)cur_cmd[VM_COMMANDS_NUM];
		if(cur_cmd_num > num)
		{ // insert command before
			DEBUG("Inserting commands in between commands");
			if(cur_cmd == vm_commands_root) vm_commands_root = new_cmd;
			prev_cmd[VM_COMMANDS_NEXT] = (u64*)new_cmd;
			new_cmd[VM_COMMANDS_NEXT] = (u64*)cur_cmd;
			break;
		}
		else if(cur_cmd_num == num)
		{ // insert command exactly at
			DEBUG("Replacing existing command");
			if(cur_cmd == vm_commands_root) vm_commands_root = new_cmd;
			prev_cmd[VM_COMMANDS_NEXT] = (u64*)new_cmd;
			new_cmd[VM_COMMANDS_NEXT] = (u64*)cur_cmd[VM_COMMANDS_NEXT];
			vm_command_free(cur_cmd);
			break;
		}
		prev_cmd = cur_cmd;
	}

	return new_cmd;
}

u64 vm_alloc_var()
{
	u64 allocated = vm_vars_allocated;
	++vm_vars_allocated;
	return allocated;
}

int strcmp_with_len(char* a, char* b, size_t b_len)
{
	for (size_t i = 0;; ++i)
	{
		char ch_a = a[i];

		if(i == b_len && ch_a == 0)
			break;

		char ch_b = b[i];

		if (ch_a < ch_b)
			return -1;
		else if (ch_a > ch_b)
			return 1;
	}
	return 0;
}

#define SYM_META_STR 0
#define SYM_META_LOC 1
#define SYM_META_LOOP_PATCH 2

u64* vm_alloc_sym_meta()
{
	size_t size = sizeof(u64)*3;
	u64* sym_meta = (u64*)malloc(size);
	NULLGAURD(sym_meta);
	memset(sym_meta, 0, size);
	return sym_meta;
}

u8 vm_intern_buffer_alloc()
{
	DEBUGS("Allocating intern buffer with size: ");
	DEBUGI(vm_intern_capacity);
	DEBUG("");

	size_t interned_symbols_size = sizeof(u64**) * vm_intern_capacity;
	vm_intern_buffer = (u64**)(malloc(interned_symbols_size));
	if(vm_intern_buffer == NULL) return 1;
	memset(vm_intern_buffer, 0, interned_symbols_size);
	return 0;
}

void resize_interned_sym_buffer()
{
	size_t old_capacity = vm_intern_capacity;
	u64** old_buffer = vm_intern_buffer;

	vm_intern_capacity = vm_intern_capacity * 2;
	vm_intern_buffer_alloc();

	DEBUG("Copying interned symbols from old to new buffer");
	for(size_t cursor = 0; cursor < old_capacity; ++cursor)
	{
		u64* sym_meta = old_buffer[cursor];
		char* str = sym_meta[SYM_META_STR];
		u32 str_hash = hash(str);
		u64 idx = (vm_intern_capacity - 1) & str_hash;

		DEBUG("Finding a spot for symbol: ");
		DEBUGS(str);
		DEBUG("");

		while(vm_intern_buffer[idx] != 0)
		{
			DEBUGS("Couldn't find a spot at index: ");
			DEBUGI(idx);
			DEBUG("");
			++idx;
			if(idx >= vm_intern_buffer) idx = 0;
		}
		DEBUG("Found a spot at index: ");
		DEBUGI(idx);
		DEBUG("");

		vm_intern_buffer[idx] = sym_meta;
	}


}

u64* vm_intern(u8* sym, u64 len, u32 hash)
{
	u64 idx = (vm_intern_capacity - 1) & hash;
	DEBUG("Interning a new sym: ");
	DEBUGS(sym);
	for(size_t cursor = idx;; ++cursor)
	{
		if (cursor >= vm_intern_capacity)
		{
			if(idx == 0) break;
			cursor = 0; 
		}

		DEBUGS("Attempting to locate symbol at index: ");
		DEBUGI(cursor);
		DEBUG("");

		u64* sym_meta = vm_intern_buffer[cursor];
		if (sym_meta == NULL)
		{
			DEBUG("Symbol not found, creating a new entry");
			char* sym_str;
			sym_str = (char*)malloc(len+1);
			NULLGAURD(sym_str);
			memcpy(sym_str, sym, len);
			sym_str[len] = 0;

			sym_meta = vm_alloc_sym_meta();
			NULLGAURD(sym_meta);
			sym_meta[SYM_META_STR] = (u64)sym_str;

			vm_intern_buffer[cursor] = (u64)sym_meta;
			return sym_meta;
		}
		else if (strcmp_with_len(sym_meta[SYM_META_STR], sym, len) == 0)
		{
			DEBUG("Symbol have been found");
			return sym_meta;
		}
		else if(cursor == (idx-1))
		{
			break;
		}
	}

	DEBUG("Not enough space in intern buffer");
	resize_interned_sym_buffer();
	DEBUG("Done resizing intern buffer");
	return vm_intern(sym, len, hash);


}

// translates symbol strings to symbols
u64 vm_get_symbol_var(u64* sym)
{
	if(sym[SYM_META_LOC] == 0)
	{
		sym[SYM_META_LOC] = ++vm_vars_allocated;
	}
	return sym[SYM_META_LOC]-1;
}

u32 hash(u8 *str)
{
	u32 hash = 5381;
	u8 c;

	while (c = *str)
	{
		hash = ((hash << 5) + hash) + c; /* hash * 33 + c */
		++str;
	}

	return hash;
}

u64* vm_commands_sym_else;
u64* vm_commands_sym_let;
u64* vm_commands_sym_goto;
u64* vm_commands_sym_run;
u64* vm_commands_sym_if;
u64* vm_commands_sym_plot;
u64* vm_commands_sym_line;
u64* vm_commands_sym_clear;
u64* vm_commands_sym_help;
u64* vm_commands_sym_blue;
u64* vm_commands_sym_red;
u64* vm_commands_sym_green;
u64* vm_commands_sym_black;
u64* vm_commands_sym_halt;

u64* vm_init_sym(char* sym)
{
	return vm_intern(sym, strlen(sym), hash(sym));
}

int vm_init()
{
	TRY(vm_intern_buffer_alloc());

	vm_commands_sym_else = vm_init_sym("ELSE");
	vm_commands_sym_let = vm_init_sym("LET");
	vm_commands_sym_goto = vm_init_sym("GOTO");
	vm_commands_sym_run = vm_init_sym("RUN");
	vm_commands_sym_if = vm_init_sym("IF");
	vm_commands_sym_plot = vm_init_sym("PLOT");
	vm_commands_sym_line = vm_init_sym("LINE");
	vm_commands_sym_clear = vm_init_sym("CLEAR");
	vm_commands_sym_help = vm_init_sym("HELP");
	vm_commands_sym_blue = vm_init_sym("BLUE");
	vm_commands_sym_red = vm_init_sym("RED");
	vm_commands_sym_green = vm_init_sym("GREEN");
	vm_commands_sym_black = vm_init_sym("BLACK");
	vm_commands_sym_halt = vm_init_sym("HALT");
	return 0;
}

void vm_command_double_size()
{
	u64* old_buff = vm_commands_selected[VM_COMMANDS_INSTS_BUFFER];
	size_t old_capacity = (size_t)vm_commands_selected[VM_COMMANDS_CAPACITY];
	size_t new_capacity = old_capacity*2;
	size_t old_size = old_capacity*sizeof(u64);
	size_t new_size = new_capacity*sizeof(u64);

	u64* new_buff = (u64*)malloc(new_size);
	if(new_buff == NULL)
	{
		DEBUG("Failed to allocate more memory for the selected command");
		exit(1);
	}

	memset(new_buff, 0, new_size);
	memcpy(new_buff, old_buff, old_size);
	vm_commands_selected[VM_COMMANDS_INSTS_BUFFER] = new_buff;
	vm_commands_selected[VM_COMMANDS_CAPACITY] = new_capacity;
	free((void*)old_buff);
}

u64 vm_bytecode_pointer_inc()
{
	u64 current_val = (u64)vm_commands_selected[VM_COMMANDS_CUR];
	vm_commands_selected[VM_COMMANDS_CUR] = (u64*)(current_val + 1);
	if(vm_commands_selected[VM_COMMANDS_CUR] >= vm_commands_selected[VM_COMMANDS_CAPACITY])
	{
		DEBUG("Exceeded command capacity");
		vm_command_double_size();
	}
	return current_val;
}

u64 vm_bytecode_get(u8 op, u64 arg)
{
	return ((u64)(op & 255) << 56) | (arg & (((u64)1<<56) - 1));
}

void vm_bytecode_patch(u64 inst_num, u8 op, u64 arg)
{
	vm_commands_selected[VM_COMMANDS_INSTS_BUFFER][inst_num] = vm_bytecode_get(op, arg);
}

void vm_bytecode_emit(u8 op, u64 arg)
{
	DEBUGS("VM command capacity");
	DEBUGI(vm_commands_selected[VM_COMMANDS_CAPACITY]);
	DEBUG("");
	u64 pos = (u64)vm_commands_selected[VM_COMMANDS_CUR];
	vm_commands_selected[VM_COMMANDS_INSTS_BUFFER][pos] = vm_bytecode_get(op, arg);
	vm_bytecode_pointer_inc();
}


void ignore_ws()
{
	while(vm_command_text_buffer_cursor > vm_command_text_buffer_read &&
			vm_command_text_buffer[vm_command_text_buffer_read] == 32)
		++vm_command_text_buffer_read;
}

u8 peek_ch(u8 n)
{
	ignore_ws();
	return (u8)vm_command_text_buffer[vm_command_text_buffer_read + n];
}

u8 peek_next()
{
	return peek_ch(0);
}

u8 read_ch()
{
	ignore_ws();
	u8 ret = (u8)vm_command_text_buffer[vm_command_text_buffer_read];
	++vm_command_text_buffer_read;
	return ret;
}

i64 read_uint() {
	ignore_ws();
	size_t start = vm_command_text_buffer_read;
	u64 acc = 0;
	while(vm_command_text_buffer_cursor > vm_command_text_buffer_read)
	{

		u8 cur_char = (u8)vm_command_text_buffer[vm_command_text_buffer_read];

		cur_char = cur_char - 48;
		if(cur_char > 9)
		{
			break;
		}

		acc = acc * 10 + cur_char;
		++vm_command_text_buffer_read;
	}

	if(start == vm_command_text_buffer_read) return -1;
	return acc;
}

u64* read_sym() {
	DEBUG("Reading sym");
	ignore_ws();
	size_t sym_start = vm_command_text_buffer_read;
	u32 hash = 5381;
	while(vm_command_text_buffer_cursor > vm_command_text_buffer_read)
	{
		u8 cur_char = (u8)vm_command_text_buffer[vm_command_text_buffer_read];
		// TODO accept symbols with numbers, _, etc
		if(!((90 >= cur_char && cur_char >= 65) || (122 >= cur_char && cur_char >= 97)))
		{
			break;
		}
		hash = ((hash << 5) + hash) + cur_char;
		++vm_command_text_buffer_read;
	}
	if(vm_command_text_buffer_read == sym_start)
	{
		return 0;
	}
	return vm_intern((u8*) (vm_command_text_buffer+sym_start), vm_command_text_buffer_read-sym_start, hash);
}

void console_error(char* err)
{
	console_newline();
	console_puts("Error: ");
	console_puts(err);
	console_newline();
}

u64 vm_emit_prim()
{
	i64 num = read_uint();
	if(num >= 0)
	{
		vm_bytecode_emit(OP_PUSH, num);
		return 0;
	}

	u64* sym = read_sym();

	if(sym != 0)
	{
		u64 var = vm_get_symbol_var(sym);
		vm_bytecode_emit(OP_GET_VAR, var);
		return 0;
	}

	char next_ch = peek_next();
	if(next_ch == '(')
	{
		read_ch();
		vm_emit_exp();
		next_ch = read_ch();
		if(next_ch != ')')
		{
			console_error("Expected to find ) but did not");
			return 1;
		}
		return 0;
	}

	if (next_ch == ')') return 0;

	console_error("Unexpected token in expression");
	return 1;
}

u64 vm_emit_factor()
{
	u8 next_ch;
	u8 op;

	TRY(vm_emit_prim());
	while(1)
	{
		next_ch = peek_next();
		if('*' ==  next_ch) op = OP_MULT;
		else if('/' == next_ch) op = OP_DIV;
		else break;

		read_ch();
		TRY(vm_emit_prim());
		vm_bytecode_emit(op, 0);
	}

	return 0;
}

u64 emit_term()
{
	u8 op;
	u8 next_ch;

	TRY(vm_emit_factor());
	while(1)
	{
		next_ch = peek_next();
		if('+' ==  next_ch) op = OP_ADD;
		else if('-' == next_ch) op = OP_SUB;
		else break;

		read_ch();
		TRY(vm_emit_factor());
		vm_bytecode_emit(op, 0);
	}
	return 0;
}

u64 vm_emit_comparison()
{
	u8 op;
	u8 next_ch;

	TRY(emit_term());
	while(1)
	{
		next_ch = peek_next();
		if('>' ==  next_ch)
		{
			read_ch();
			next_ch = peek_next();
			op = OP_GT;
			if ('=' == next_ch)
			{
				op = OP_GT_EQ;
				read_ch();
			} 
		} else if('<' == next_ch)
		{
			read_ch();
			next_ch = peek_next();
			op = OP_LT;
			if ('=' == next_ch)
			{
				op = OP_LT_EQ;
				read_ch();
			}
		} else break;

		TRY(emit_term());
		vm_bytecode_emit(op, 0);
	}
	return 0;
}

u64 vm_emit_exp()
{
	u8 op;
	u8 next_ch;

	TRY(vm_emit_comparison());

	while(1)
	{
		next_ch = peek_next();

		if(next_ch == '!' && peek_ch(1) == '=') op = OP_NOT_EQ;
		else if(next_ch == '=' && peek_ch(1) == '=') op = OP_EQ;
		else break;
		read_ch();
		read_ch();
		TRY(vm_emit_comparison());

		vm_bytecode_emit(op, 0);
	}
	return 0;
}

u64 vm_emit_color()
{
	u64* color = read_sym();
	if(color == 0)
	{
		TRY(vm_emit_exp());
	}
	else
	{
		u64 color_val;
		if(color == vm_commands_sym_blue) color_val = blue;
		else if(color == vm_commands_sym_red) color_val = red;
		else if(color == vm_commands_sym_green) color_val = green;
		else if(color == vm_commands_sym_black) color_val = black;
		else
		{
			console_error("Unrecognized color");
			return 1;
		}
		DEBUGS("PUSHING COLOR: ");
		DEBUGI(color_val);
		DEBUG("")
			vm_bytecode_emit(OP_PUSH, color_val);
	}
}

u8 vm_emit_cmd()
{
	DEBUG("Emitting command");
	u64* command = read_sym();

	if(command == vm_commands_sym_help)
	{
		DEBUG("Emitting help command");
		vm_bytecode_emit(OP_HELP, 0);

	}
	else if(command == vm_commands_sym_let)
	{
		DEBUG("Emitting LET command");
		u64* sym = read_sym();
		if (sym == NULL)
		{
			console_error("LET is expected to be followed by a symbol but was not");
			return 1;
		}
		TRY(vm_emit_exp());
		u64 var = vm_get_symbol_var(sym);
		vm_bytecode_emit(OP_SET_VAR , var);
	}
	else if (command == vm_commands_sym_goto)
	{
		DEBUG("Emitting GOTO");
		TRY(vm_emit_exp());
		vm_bytecode_emit(OP_GOTO, 0);
	}
	else if (command == vm_commands_sym_if)
	{
		DEBUG("Emitting IF");
		TRY(vm_emit_exp());
		u64 jump_to_else_pos = vm_bytecode_pointer_inc(); // resever inst to jump to else if pred is false
		TRY(vm_emit_cmd()); // Then cmd

		u64 jump_to_else_end_pos = vm_bytecode_pointer_inc(); // reserve inst to jump to end of else;

		// emitting else
		u64* else_sym = read_sym();
		if(else_sym != vm_commands_sym_else) {
			console_error("Expected the Then clause to be followed by ELSE");
			return 1;
		}
		u64 start_of_else = (u64)vm_commands_selected[VM_COMMANDS_CUR];
		TRY(vm_emit_cmd()); // Then cmd

		u64 end_of_else = (u64)vm_commands_selected[VM_COMMANDS_CUR];

		vm_bytecode_patch(jump_to_else_pos, OP_JUMP_IF_NOT, start_of_else);
		vm_bytecode_patch(jump_to_else_end_pos, OP_JUMP, end_of_else);
	}
	else if (command == vm_commands_sym_plot)
	{
		DEBUG("Emitting plot");
		TRY(vm_emit_exp());
		TRY(vm_emit_exp());
		TRY(vm_emit_color());
		vm_bytecode_emit(OP_PLOT, 0);
	}
	else if (command == vm_commands_sym_line)
	{
		DEBUG("Emitting line");
		TRY(vm_emit_exp());
		TRY(vm_emit_exp());
		TRY(vm_emit_exp());
		TRY(vm_emit_exp());
		TRY(vm_emit_color());
		vm_bytecode_emit(OP_LINE, 0);
	}
	else if (command == vm_commands_sym_halt)
	{
		DEBUG("Emitting clear");
		vm_bytecode_emit(OP_HALT, 0);
	}
	else if (command == vm_commands_sym_clear)
	{
		DEBUG("Emitting clear");
		vm_bytecode_emit(OP_CLEAN, 0);
	}
	else if (command == vm_commands_sym_run)
	{
		DEBUG("Running loaded commands");
		vm_exec(vm_commands_root); 
	}
	else if (read_sym() == NULL)
	{
		DEBUG("Printing symbol value");
		if(command == NULL) return 1;
		u64 var = vm_get_symbol_var(command);
		console_newline();
		console_print_i64(vm_vars[var]);
	}
	else
	{
		console_error("Unrecognized command");
		return 1;
	}

	return 0;
}

void vm_load_cmd() {

	if(vm_command_text_buffer_cursor == 0) return;

	DEBUGS(vm_command_text_buffer);

	i64 cmd_num = read_uint();
	DEBUG("cmd_num\n");
	DEBUGI(cmd_num);
	DEBUG("");
	u64** cmd;
	if(cmd_num < 0)
	{
		DEBUG("Creating disposable cmd");
		cmd = vm_commands_alloc(cmd_num);
	}
	else
	{
		DEBUG("Retrieving cmd");
		cmd = vm_command_create(cmd_num);
	}

	if(cmd == NULL)
	{
		DEBUG("Failed to allocate command");
		return;
	}

	vm_commands_selected = cmd;

	if(vm_emit_cmd())
	{
		if(cmd_num >= 0) vm_command_create(cmd_num);
		else vm_command_free(cmd);
	}
	else if(cmd_num < 0)
	{
		vm_exec(cmd);
		vm_command_free(cmd);
	}

	vm_command_text_buffer_clear();
	console_print_ready();
}

i64 vm_pop() {
	i64 val = vm_stack[--vm_stack_cursor];
	vm_stack[vm_stack_cursor] = 0;
	return val;
}

void vm_push(i64 v) {
	vm_stack[vm_stack_cursor] = v;
	++vm_stack_cursor;
}

#define BIN_OP(opcode, c_op)			\
	else if (op == opcode) \
{							\
	val2 = vm_pop();				\
	val1 = vm_pop();				\
	DEBUGS("OP: ");				\
	DEBUGI(op);					\
	DEBUGS("\n");				\
	DEBUGS("val1: ");				\
	DEBUGI(val1);				\
	DEBUGS("\n");				\
	DEBUGS("val2: ");				\
	DEBUGI(val2);				\
	DEBUGS("\n");				\
	i64 result = val1 c_op val2;		\
	DEBUGS("result: ");				\
	DEBUGI(result);				\
	DEBUGS("\n");				\
	vm_push(result);				\
}

#define PRINT_OP(op_str, op_name) else if(op == op_name) \
{								\
	puts(op_str);						\
}		 
void print_inst(u64 inst)
{
	u8 op = (u8)(inst >> 56);
	u64 arg = (inst & (((u64)1<<56) - 1));
	puts("ints:");
	print_i64(inst);
	puts("\n");
	puts("op:");
	print_i64(op);
	puts("\n");
	puts("name:");
	if(0){}
	PRINT_OP("OP_PUSH", OP_PUSH)
	PRINT_OP("OP_SET_VAR", OP_SET_VAR)
	PRINT_OP("OP_GET_VAR", OP_GET_VAR)
	PRINT_OP("OP_JUMP", OP_JUMP)
	PRINT_OP("OP_JUMP_IF", OP_JUMP_IF)
	PRINT_OP("OP_JUMP_IF_NOT", OP_JUMP_IF_NOT)
	PRINT_OP("OP_ADD", OP_ADD)
	PRINT_OP("OP_SUB", OP_SUB)
	PRINT_OP("OP_MULT", OP_MULT)
	PRINT_OP("OP_DIV", OP_DIV)
	PRINT_OP("OP_GT", OP_GT)
	PRINT_OP("OP_LT", OP_LT)
	PRINT_OP("OP_GT_EQ", OP_GT_EQ)
	PRINT_OP("OP_LT_EQ", OP_LT_EQ)
	PRINT_OP("OP_EQ", OP_EQ)
	PRINT_OP("OP_NOT_EQ", OP_NOT_EQ)
	PRINT_OP("OP_PRINT_INT", OP_PRINT_INT)
	PRINT_OP("OP_GOTO", OP_GOTO)


	puts("\n");
	puts("arg:");
	print_i64(arg);
	puts("\n");
}

void print_insts(u64** cmd)
{
	u64* cmd_insts = cmd[VM_COMMANDS_INSTS_BUFFER];
	u64 cmd_size = (u64)cmd[VM_COMMANDS_CUR];
	puts("INSTRUCTION PRINTOUT \n");
	for(size_t inst_idx = 0; (inst_idx < cmd_size); ++inst_idx)
	{
		puts("--------------\n");
		u64 inst = cmd_insts[inst_idx];
		puts("idx:");
		print_i64(inst_idx);
		puts("\n");
		print_inst(inst);
	}

	puts("-- END INSTRUCTION PRINTOUT");
}


void vm_exec(u64** commands)
{
	u64** next_cmd ;
	i64 val1;
	i64 val2;
	for(u64** cmd = commands; cmd != 0; cmd = next_cmd)
	{
		next_cmd = (u64**) cmd[VM_COMMANDS_NEXT];
		u64 cur_cmd_num = (u64)cmd[VM_COMMANDS_NUM];

		u64* cmd_insts = cmd[VM_COMMANDS_INSTS_BUFFER];
		u64 cmd_size = (u64)cmd[VM_COMMANDS_CUR];

		for(size_t inst_idx = 0; (inst_idx < cmd_size); )
		{
			u64 inst = cmd_insts[inst_idx];
			u8 op = (u8)(inst >> 56);
			u64 arg = (inst & (((u64)1<<56) - 1));

			// TODO check for overflow
			if(op == OP_PUSH) vm_push(arg);
			else if (op == OP_SET_VAR) vm_vars[arg] = vm_pop();
			else if (op == OP_GET_VAR) vm_push(vm_vars[arg]);
			else if (op == OP_PRINT_INT)
			{
			  console_newline();
			  console_print_i64(vm_pop());
			}
			else if (op == OP_GOTO) next_cmd = vm_command_find(vm_pop());
			else if (op == OP_HALT) return;
			else if (op == OP_HELP)
			{
				console_newline();
				console_puts("UVM Basic commands");
				console_newline();
				console_puts("LET {sym} {expr}");
				console_newline();
				console_puts("GOTO {cmd num}");
				console_newline();
				console_puts("IF {pred} {then} ELSE {else}");
				console_newline();
				console_puts("PLOT {x} {y} {color}");
				console_newline();
				console_puts("LINE {x0} {y0} {x1} {y1} {color}");
				console_newline();
				console_puts("CLEAR");
				console_newline();
				console_puts("RUN: runs loaded commands");
				console_newline();
				console_puts("HALT: stops RUN");
				console_newline();
				console_puts("Supported colors: blue, red, green, black");
				console_newline();
				console_puts("The canvas size is ");
				console_print_i64(FRAME_WIDTH - console_width-CANVAS_PLOT_POINT_SIZE);
				console_puts("X");
				console_print_i64(FRAME_HEIGHT-CANVAS_PLOT_POINT_SIZE);
			}
			else if (op == OP_JUMP)
			{
				if (arg > cmd_size) break;
				DEBUG("Unconditionally jumping");
				inst_idx = arg;
				continue;
			}
			else if (op == OP_JUMP_IF_NOT)
			{
				DEBUG("EXECUTING OP_JUMP_IF_NOT");
				if (arg > cmd_size) break;
				if(!vm_pop()) {
					DEBUG("DETECTED A NOT SO jumping");
					inst_idx = arg;
					continue;
				}
			}
			else if (op == OP_PLOT)
			{
				u64 color = vm_pop();
				u64 y = vm_pop();
				u64 x = vm_pop();
				canvas_plot(x, y, color);
			}
			else if (op == OP_LINE)
			{
				u32 color = (u32)vm_pop();
				u32 y1 = (u32)vm_pop();
				u32 x1 = (u32)vm_pop();
				u32 y0 = (u32)vm_pop();
				u32 x0 = (u32)vm_pop();
				if(canvas_coord_gaurd(x0, y0)) break;
				if(canvas_coord_gaurd(x1, y1)) break;
				draw_line((u32*)frame_buffer, FRAME_WIDTH, FRAME_HEIGHT,  console_width + x0, y0,  console_width + x1, y1, color);
			}
			else if (op == OP_CLEAN)
			{
				canvas_clear();
				console_redraw_all_text();
			}
			BIN_OP(OP_ADD, +)
				BIN_OP(OP_SUB, -)
				BIN_OP(OP_MULT, *)
				BIN_OP(OP_DIV, /)
				BIN_OP(OP_GT, >)
				BIN_OP(OP_LT, <)
				BIN_OP(OP_GT_EQ, >=)
				BIN_OP(OP_LT_EQ, <=)
				BIN_OP(OP_EQ, ==)
				BIN_OP(OP_NOT_EQ, !=)
			else
			{
				DEBUG("unrecognized command");
				return;
			}
			DEBUG("executing inst");
			++inst_idx;
		}
	}
}
